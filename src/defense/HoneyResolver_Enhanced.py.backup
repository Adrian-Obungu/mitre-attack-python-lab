#!/usr/bin/env python3
"""
Enhanced DNS Honeypot Resolver
Author: Adrian S. Obungu
"""

import time
import random
import logging
from dnslib import *
from dnslib.server import DNSServer

# Configuration
HONEYPOT_DOMAIN = "example.com"
LISTEN_ADDR = "0.0.0.0"
LISTEN_PORT = 8053

# Real subdomains (legitimate services)
REAL_SUBDOMAINS = {
    "www": "93.184.216.34",  # example.com
    "mail": "203.0.113.10",
    "smtp": "203.0.113.25",
}

# Fake subdomains (honeypots) with unique IPs
FAKE_SUBDOMAINS = {
    "admin": "10.0.1.1",
    "vpn": "10.0.1.2",
    "secure": "10.0.1.3",
    "portal": "10.0.1.4",
    "api": "10.0.1.5",
}

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/honeyresolver.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EnhancedHoneyResolver:
    def __init__(self):
        self.query_count = 0
        logger.info(f"Initialized HoneyResolver for domain: {HONEYPOT_DOMAIN}")
    
    def get_response_ip(self, subdomain):
        """Determine which IP to return for a given subdomain"""
        subdomain_lower = subdomain.lower()
        
        # Check real subdomains
        if subdomain_lower in REAL_SUBDOMAINS:
            return REAL_SUBDOMAINS[subdomain_lower], "real"
        
        # Check fake subdomains
        if subdomain_lower in FAKE_SUBDOMAINS:
            return FAKE_SUBDOMAINS[subdomain_lower], "fake"
        
        # Generate random IP for unknown subdomains
        random_ip = f"10.0.2.{random.randint(1, 254)}"
        return random_ip, "random"
    
    def resolve(self, request, handler):
        """Main resolver function"""
        self.query_count += 1
        
        # Extract query details
        qname = str(request.q.qname)
        qtype = request.q.qtype
        
        # Extract subdomain
        domain_suffix = f".{HONEYPOT_DOMAIN}."
        if qname.endswith(domain_suffix):
            subdomain = qname[:-len(domain_suffix)]
        else:
            subdomain = qname
        
        # Get client IP
        client_ip = handler.client_address[0]
        
        # Determine response
        response_ip, category = self.get_response_ip(subdomain)
        
        # Log the query
        logger.info(f"Query from {client_ip}: {qname} (Type: {QTYPE[qtype]}) -> {response_ip} ({category})")
        
        # Build response
        reply = request.reply()
        
        # Handle different query types
        if qtype == QTYPE.A:
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.A,
                rclass=1,
                ttl=300,
                rdata=A(response_ip)
            ))
        elif qtype == QTYPE.AAAA:
            # Return a fake IPv6 address
            fake_ipv6 = f"2001:db8::{random.randint(1, 65535):x}:{random.randint(1, 65535):x}"
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.AAAA,
                rclass=1,
                ttl=300,
                rdata=AAAA(fake_ipv6)
            ))
        elif qtype == QTYPE.MX:
            # Mail exchange record
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.MX,
                rclass=1,
                ttl=300,
                rdata=MX(10, f"mail.{HONEYPOT_DOMAIN}.")
            ))
        else:
            # Default to A record
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.A,
                rclass=1,
                ttl=300,
                rdata=A(response_ip)
            ))
        
        return reply

def main():
    """Main function to run the DNS honeypot"""
    print("="*60)
    print("Enhanced DNS HoneyResolver")
    print("="*60)
    print(f"Domain: {HONEYPOT_DOMAIN}")
    print(f"Listening on: {LISTEN_ADDR}:{LISTEN_PORT}")
    print(f"Real subdomains: {len(REAL_SUBDOMAINS)}")
    print(f"Fake subdomains: {len(FAKE_SUBDOMAINS)}")
    print("="*60)
    print("Press Ctrl+C to stop")
    print("="*60)
    
    # Create logs directory if it doesn't exist
    import os
    os.makedirs("logs", exist_ok=True)
    
    # Create and start resolver
    resolver = EnhancedHoneyResolver()
    server = DNSServer(resolver, port=LISTEN_PORT, address=LISTEN_ADDR)
    
    try:
        server.start()
    except KeyboardInterrupt:
        print("\nShutting down...")
        server.stop()
        print(f"Total queries handled: {resolver.query_count}")

if __name__ == "__main__":
    main()
EOF# Backup the original

# Create a corrected version
cat > src/defense/HoneyResolver_Enhanced.py << 'EOF'
#!/usr/bin/env python3
"""
Enhanced DNS Honeypot Resolver
Author: Adrian S. Obungu
"""

import time
import random
import logging
from dnslib import *
from dnslib.server import DNSServer

# Configuration
HONEYPOT_DOMAIN = "example.com"
LISTEN_ADDR = "0.0.0.0"
LISTEN_PORT = 8053

# Real subdomains (legitimate services)
REAL_SUBDOMAINS = {
    "www": "93.184.216.34",  # example.com
    "mail": "203.0.113.10",
    "smtp": "203.0.113.25",
}

# Fake subdomains (honeypots) with unique IPs
FAKE_SUBDOMAINS = {
    "admin": "10.0.1.1",
    "vpn": "10.0.1.2",
    "secure": "10.0.1.3",
    "portal": "10.0.1.4",
    "api": "10.0.1.5",
}

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/honeyresolver.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EnhancedHoneyResolver:
    def __init__(self):
        self.query_count = 0
        logger.info(f"Initialized HoneyResolver for domain: {HONEYPOT_DOMAIN}")
    
    def get_response_ip(self, subdomain):
        """Determine which IP to return for a given subdomain"""
        subdomain_lower = subdomain.lower()
        
        # Check real subdomains
        if subdomain_lower in REAL_SUBDOMAINS:
            return REAL_SUBDOMAINS[subdomain_lower], "real"
        
        # Check fake subdomains
        if subdomain_lower in FAKE_SUBDOMAINS:
            return FAKE_SUBDOMAINS[subdomain_lower], "fake"
        
        # Generate random IP for unknown subdomains
        random_ip = f"10.0.2.{random.randint(1, 254)}"
        return random_ip, "random"
    
    def resolve(self, request, handler):
        """Main resolver function"""
        self.query_count += 1
        
        # Extract query details
        qname = str(request.q.qname)
        qtype = request.q.qtype
        
        # Extract subdomain
        domain_suffix = f".{HONEYPOT_DOMAIN}."
        if qname.endswith(domain_suffix):
            subdomain = qname[:-len(domain_suffix)]
        else:
            subdomain = qname
        
        # Get client IP
        client_ip = handler.client_address[0]
        
        # Determine response
        response_ip, category = self.get_response_ip(subdomain)
        
        # Log the query
        logger.info(f"Query from {client_ip}: {qname} (Type: {QTYPE[qtype]}) -> {response_ip} ({category})")
        
        # Build response
        reply = request.reply()
        
        # Handle different query types
        if qtype == QTYPE.A:
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.A,
                rclass=1,
                ttl=300,
                rdata=A(response_ip)
            ))
        elif qtype == QTYPE.AAAA:
            # Return a fake IPv6 address
            fake_ipv6 = f"2001:db8::{random.randint(1, 65535):x}:{random.randint(1, 65535):x}"
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.AAAA,
                rclass=1,
                ttl=300,
                rdata=AAAA(fake_ipv6)
            ))
        elif qtype == QTYPE.MX:
            # Mail exchange record
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.MX,
                rclass=1,
                ttl=300,
                rdata=MX(10, f"mail.{HONEYPOT_DOMAIN}.")
            ))
        else:
            # Default to A record
            reply.add_answer(RR(
                rname=request.q.qname,
                rtype=QTYPE.A,
                rclass=1,
                ttl=300,
                rdata=A(response_ip)
            ))
        
        return reply

def main():
    """Main function to run the DNS honeypot"""
    print("="*60)
    print("Enhanced DNS HoneyResolver")
    print("="*60)
    print(f"Domain: {HONEYPOT_DOMAIN}")
    print(f"Listening on: {LISTEN_ADDR}:{LISTEN_PORT}")
    print(f"Real subdomains: {len(REAL_SUBDOMAINS)}")
    print(f"Fake subdomains: {len(FAKE_SUBDOMAINS)}")
    print("="*60)
    print("Press Ctrl+C to stop")
    print("="*60)
    
    # Create logs directory if it doesn't exist
    import os
    os.makedirs("logs", exist_ok=True)
    
    # Create and start resolver
    resolver = EnhancedHoneyResolver()
    server = DNSServer(resolver, port=LISTEN_PORT, address=LISTEN_ADDR)
    
    try:
        server.start()
    except KeyboardInterrupt:
        print("\nShutting down...")
        server.stop()
        print(f"Total queries handled: {resolver.query_count}")

if __name__ == "__main__":
    main()
