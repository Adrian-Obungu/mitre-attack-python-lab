# -*- coding: utf-8 -*-
"""
log_parser.py: Log Parser and Analytics for DNS Honeypot Logs

This script parses the log files generated by HoneyResolver_Enhanced.py,
extracts query statistics, and provides threat scoring based on observed
DNS query patterns.

Features:
- Parses honeyresolver.log for DNS query data.
- Provides analytics: total queries, queries per source IP, top queried domains.
- Threat scoring based on query patterns (e.g., queries for fake subdomains, high query volume).
"""

import argparse
import re
from collections import defaultdict, Counter
import json
import os
from typing import Dict, List, Any
import logging
import sys
import time

# --- Configuration ---
DEFAULT_LOG_FILE = "honeyresolver.log" # Assumes log file is in the same directory as this parser, or specify full path

# Threat scoring based on query patterns
# These scores are indicative and can be adjusted based on desired sensitivity
THREAT_SCORES = {
    "fake_subdomain_query": 50, # High score for querying explicit honeypot domains
    "high_query_volume_threshold": 100, # Threshold for flagging high volume
    "high_query_volume_score": 20, # Score for exceeding volume threshold
    "suspicious_qtype_query": 10,
    "admin_query": 75,
    "vpn_query": 60,
    "internal_query": 60,
    "db_query": 50,
    "sql_query": 50,
    "secret_query": 75,
    "private_query": 75,
    "backup_query": 40,
    "remote_query": 30,
    "cname_to_fake": 30, # Querying a CNAME that resolves to a fake honeypot
}

# Setup basic logging for the parser itself
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
# Prevent duplicate handlers if this module is imported multiple times
if not logger.handlers:
    console_handler = logging.StreamHandler(sys.stdout)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

class LogParser:
    """
    Parses DNS honeypot logs, extracts statistics, and calculates threat scores.
    """
    def __init__(self, log_file_path: str):
        """
        Initializes the LogParser with the path to the log file.

        Args:
            log_file_path: The path to the honeyresolver log file.
        """
        self.log_file_path = log_file_path
        self.parsed_entries: List[Dict[str, Any]] = []
        self.query_stats = defaultdict(lambda: defaultdict(int)) # {client_ip: {qtype: count, qname: count, score: int}}
        self.total_queries = 0
        self.top_queried_domains = Counter()

    def parse_logs(self):
        """
        Reads and parses each line of the log file.
        """
        if not os.path.exists(self.log_file_path):
            logger.error(f"Log file not found: {self.log_file_path}")
            return

        logger.info(f"Parsing log file: {self.log_file_path}")
        with open(self.log_file_path, 'r', encoding='utf-8') as f:
            for line in f:
                self._parse_log_line(line)
        logger.info(f"Finished parsing. Total entries: {len(self.parsed_entries)}")

    def _parse_log_line(self, line: str):
        """
        Parses a single log line and extracts relevant information.
        """
        # Example log line: "2025-12-06 03:05:00,123 - INFO - DNS Query: Client 192.168.1.1 requested 'www.example.com.' (A)"
        # Or: "2025-12-06 03:05:00,123 - WARNING - HONEYPOT HIT: Client 192.168.1.1 queried for fake subdomain 'admin.example.com' (A)"
        match = re.search(
            r"Client (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}).*(HONEYPOT HIT:|DNS Query:|DYNAMIC HONEYPOT:).*'([^']+?)' (\(\w+\))",
            line
        )
        if match:
            client_ip = match.group(1)
            log_type = match.group(2).strip(':')
            qname = match.group(3).lower().strip('.')
            qtype = match.group(4).strip('()') # Strip parentheses from QTYPE

            entry = {
                "client_ip": client_ip,
                "qname": qname,
                "qtype": qtype,
                "is_honeypot_hit": "HONEYPOT" in log_type
            }
            self.parsed_entries.append(entry)
            self._update_statistics(entry)
        else:
            # Catch dynamic honeypot logs or other relevant lines
            dynamic_match = re.search(
                r"DYNAMIC HONEYPOT: Client (\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}).*queried for unknown subdomain '([^']+?)'",
                line
            )
            if dynamic_match:
                client_ip = dynamic_match.group(1)
                qname = dynamic_match.group(2).lower().strip('.')
                entry = {
                    "client_ip": client_ip,
                    "qname": qname,
                    "qtype": "A", # Dynamic honeypots typically for A records
                    "is_honeypot_hit": True,
                    "is_dynamic": True
                }
                self.parsed_entries.append(entry)
                self._update_statistics(entry)


    def _update_statistics(self, entry: Dict[str, Any]):
        """Updates internal statistics based on a parsed log entry."""
        self.total_queries += 1
        client_ip = entry["client_ip"]
        qname = entry["qname"]
        qtype = entry["qtype"]

        self.query_stats[client_ip]["total_queries"] += 1
        self.query_stats[client_ip][f"qtype_{qtype}"] += 1
        self.query_stats[client_ip]["queried_domains"].append(qname)
        self.top_queried_domains[qname] += 1
        
        # Initialize threat score for client if not present
        if "threat_score" not in self.query_stats[client_ip]:
            self.query_stats[client_ip]["threat_score"] = 0

        # Apply threat scoring
        if entry["is_honeypot_hit"]:
            self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["fake_subdomain_query"]
            self.query_stats[client_ip]["honeypot_hits"] += 1
            # Specific subdomain scoring
            if "admin" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["admin_query"]
            if "vpn" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["vpn_query"]
            if "internal" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["internal_query"]
            if "db" in qname or "sql" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["db_query"]
            if "secret" in qname or "private" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["secret_query"]
            if "backup" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["backup_query"]
            if "remote" in qname:
                self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["remote_query"]
            
            if entry.get("is_dynamic"):
                self.query_stats[client_ip]["threat_score"] += (THREAT_SCORES["fake_subdomain_query"] // 2) # Slightly lower for dynamic, still suspicious

        # High query volume
        if self.query_stats[client_ip]["total_queries"] > THREAT_SCORES["high_query_volume_threshold"]:
            self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["high_query_volume_score"]
            self.query_stats[client_ip]["high_volume_flag"] = True
        
        # Suspicious QTYPEs (e.g., ANY queries, or other unusual types if they appear)
        # Note: HoneyResolver_Enhanced currently only logs common types, but this can be extended
        if qtype == "ANY": # QTYPE.ANY is not currently handled explicitly by HoneyResolver, but good to have
             self.query_stats[client_ip]["threat_score"] += THREAT_SCORES["suspicious_qtype_query"]

    def generate_report(self):
        """Generates and prints a comprehensive analytics report."""
        print("\n" + "="*80)
        print("                 HONEYRESOLVER LOG ANALYSIS REPORT                 ")
        print("="*80 + "\n")

        print(f"Log File: {self.log_file_path}")
        print(f"Analysis Date: {time.ctime()}")
        print("="*80 + "\n")

        print(f"Total DNS Queries Processed: {self.total_queries}\n")

        print("--- Top 10 Queried Domains ---")
        for qname, count in self.top_queried_domains.most_common(10):
            print(f"  {qname}: {count} queries")
        print("------------------------------\n")

        print("--- Client IP Analysis ---")
        sorted_clients = sorted(
            self.query_stats.items(),
            key=lambda item: item[1].get("threat_score", 0),
            reverse=True
        )

        for client_ip, stats in sorted_clients:
            score = stats.get("threat_score", 0)
            status = "Suspicious" if score > 0 else "Normal"
            if stats.get("high_volume_flag"):
                status += ", High Volume"

            print(f"\nClient IP: {client_ip} (Threat Score: {score}, Status: {status})")
            print(f"  Total Queries: {stats['total_queries']}")
            if stats.get("honeypot_hits"):
                print(f"  Honeypot Hits: {stats['honeypot_hits']}")
            
            print("  Query Types:")
            for qtype, count in stats.items():
                if qtype.startswith("qtype_"):
                    print(f"    {qtype.replace('qtype_', '')}: {count} queries")
            
            # Print unique queried domains for suspicious clients
            if score > 0 and stats.get("queried_domains"):
                unique_domains = sorted(list(set(stats["queried_domains"])))
                print("  Unique Queried Domains:")
                for domain in unique_domains:
                    print(f"    - {domain}")
        print("="*80 + "\n")

def main():
    """Main function to parse arguments and run the log analysis."""
    parser = argparse.ArgumentParser(
        description="Parse HoneyResolver logs and generate analytics with threat scoring."
    )
    parser.add_argument(
        "log_file",
        nargs="?", # Makes the argument optional
        default=DEFAULT_LOG_FILE,
        help=f"Path to the HoneyResolver log file (default: {DEFAULT_LOG_FILE})."
    )
    args = parser.parse_args()

    # Ensure log_parser uses its own console handler for reporting, not the HoneyResolver's
    # Remove existing handlers to avoid duplicate output
    if logger.hasHandlers():
        logger.handlers.clear()
    logger.addHandler(logging.StreamHandler(sys.stdout))

    log_parser = LogParser(args.log_file)
    log_parser.parse_logs()
    log_parser.generate_report()

if __name__ == "__main__":
    main()
